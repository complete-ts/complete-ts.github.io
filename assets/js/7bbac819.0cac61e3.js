"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3032],{8121:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var s=t(1085),r=t(1184);const a={},o="require-unannotated-const-assertions",i={id:"eslint-plugin-complete/rules/require-unannotated-const-assertions",title:"require-unannotated-const-assertions",description:"Disallows explicit type annotations for variables that have a const assertion.",source:"@site/docs/eslint-plugin-complete/rules/require-unannotated-const-assertions.md",sourceDirName:"eslint-plugin-complete/rules",slug:"/eslint-plugin-complete/rules/require-unannotated-const-assertions",permalink:"/eslint-plugin-complete/rules/require-unannotated-const-assertions",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"require-capital-read-only",permalink:"/eslint-plugin-complete/rules/require-capital-read-only"},next:{title:"require-variadic-function-argument",permalink:"/eslint-plugin-complete/rules/require-variadic-function-argument"}},l={},c=[{value:"Rule Details",id:"rule-details",level:2},{value:"Options and Defaults",id:"options-and-defaults",level:2},{value:"Resources",id:"resources",level:2}];function u(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"require-unannotated-const-assertions",children:(0,s.jsx)(n.code,{children:"require-unannotated-const-assertions"})})}),"\n",(0,s.jsxs)(n.p,{children:["Disallows explicit type annotations for variables that have a ",(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions",children:"const assertion"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"rule-details",children:"Rule Details"}),"\n",(0,s.jsx)(n.p,{children:'A "const assertion" is a useful feature of TypeScript that changes the type to the narrowest possible setting. Good TypeScript codebases will make heavy use of this feature in order to make their variables as safe as possible.'}),"\n",(0,s.jsxs)(n.p,{children:["However, if a variable has both an explicit type annotation and a const assertion, then the const assertion will be ignored and the type annotation will take precedence. Thus, this situation is almost always a mistake, and you should choose to have ",(0,s.jsx)(n.em,{children:"either"})," a type annotation or a const assertion (with the latter being the generally safer option)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Bad\nconst array: number[] = [1, 2, 3] as const;\n\n// Good\nconst array = [1, 2, 3] as const;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"options-and-defaults",children:"Options and Defaults"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "rules": {\n    "complete/require-unannotated-const-assertions": "error"\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This rule is not configurable."}),"\n",(0,s.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"../..",children:"How to use this rule"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/complete-ts/complete/blob/main/packages/eslint-plugin-complete/src/rules/require-unannotated-const-assertions.ts",children:"Rule source"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/complete-ts/complete/blob/main/packages/eslint-plugin-complete/tests/rules/require-unannotated-const-assertions.test.ts",children:"Test source"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},1184:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(4041);const r={},a=s.createContext(r);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);